# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_wandb.ipynb.

# %% auto 0
__all__ = ['WandbConfig', 'ImageDatasetLogger', 'ImagePredictionsLogger']

# %% ../nbs/02_wandb.ipynb 2
import torch
from torch.utils.data import Dataset
from pathlib import Path
from dataclasses import dataclass

import wandb
from fastprogress import progress_bar

from .utils import not_none

# %% ../nbs/02_wandb.ipynb 3
@dataclass
class WandbConfig:
    "A minimal config for wandb"
    project: str
    entity: str = None

# %% ../nbs/02_wandb.ipynb 6
class ImageDatasetLogger:
    "Log a torchvision dataset with Images as a Table"
    def __init__(self, 
                 ds: Dataset, 
                 n:int=None, 
                 log_raw:bool=True,
                 log2workspace:bool=True, 
                 artifact_name:str="image_dataset",
                 table_name:str="image_dataset_table"
                ):
        
        self.ds = ds
        self.n = n
        self.log_raw = log_raw
        self.log2workspace = log2workspace
        self.artifact_name = artifact_name
        self.table_name = table_name
        
        # create artifact
        self.ds_at = wandb.Artifact(self.artifact_name, type="data")
            
        
    def __repr__(self):
        return self.ds.__repr__()
    
    def add_raw(self):
        try:
            path = Path(getattr(self.ds, "raw_folder")).parent
            self.ds_at.add_dir(path)
        except:
            raise Exception("Error finding the folder for the dataset")
    
    def _dataset_table(self):
        "Create a wanb.Table with validation data" 
        ds_table = wandb.Table(columns = ["image", "label"])
        pbar = progress_bar(self.ds, total=len(self.ds), leave=False)
        pbar.comment = "Creating W&B Table with validation DL"
        for i, (img, lbl) in enumerate(pbar):
            if self.n is not None and i>=self.n:
                break
            ds_table.add_data(wandb.Image(img), lbl)
        return ds_table
    
    def add_dataset_table(self):
        "Add the dataset as a wandb.Table"
        self.ds_table = self._dataset_table()
        
        assert wandb.run is not None, "Execute this function within a wandb run"
        self.ds_at.add(self.ds_table, self.table_name)
            
    def _log(self):
        # log to W&B
        wandb.log_artifact(self.ds_at)
        
        # log table also to workspace
        if self.log2workspace:
            wandb.log({self.table_name: self.ds_table})
            
    def log_table(self):    
        # add table
        self.add_dataset_table()
        
        # log to W&B
        self._log()
        
    def log_all(self):
        # add raw folder
        if self.log_raw and self.n is None:
            self.add_raw()
        
        self.log_table()

# %% ../nbs/02_wandb.ipynb 11
class ImagePredictionsLogger:
    """
    Log model predictions on the validation datasets, it references the previously logged dataset
    """
    def __init__(self, ds_data_at=None, ds_table_name=None, logits=True, log2workspace=True):
        
        self.ds_data_at = ds_data_at
        self.ds_table_name = ds_table_name
        self.logits = logits
        self.log2workspace = log2workspace
        
        if not_none([ds_data_at, ds_table_name]):
            self.ds_table = self._get_reference_table(ds_data_at, ds_table_name)
            
        
    def _get_reference_table(self, ds_data_at, ds_table_name):
        artifact = wandb.use_artifact(ds_data_at, type='data')
        return artifact.get(ds_table_name)
    
    def _init_preds_table(self, num_classes=10):
        "Create predictions table"
        columns = ["image", "label", "preds"]
        columns += [f"prob_{i}" for i in range(num_classes)] if self.logits else []
        self.preds_table = wandb.Table(columns=columns)
        
    def create_preds_table(self, preds, n_preds=None):
        if self.ds_table is None:
            print("No val table reference found")
            return
        table_idxs = self.ds_table.get_index()
        
        if isinstance(preds, torch.Tensor):
            preds = preds.cpu().numpy()
        
        n_preds = min(preds.shape[0], n_preds)
        
        for idx in progress_bar(table_idxs[:n_preds], leave=False):
            pred = preds[idx]
            row =  [self.ds_table.data[idx][0], self.ds_table.data[idx][1]]
            row += [pred.argmax(), *pred] if self.logits else [pred]
            self.preds_table.add_data(*row)

    
    def log(self, preds, n_preds=None, table_name="preds_table", aliases=None):
        if len(preds.shape) == 2:
            num_classes = preds.shape[1]
        else:
            raise Error("The preds tensor must have rank 1 or 2, no more or less")
            
        # create the Predictions Table 
        self._init_preds_table(num_classes=num_classes)
        
        # Populate the Table with the model predictions
        self.create_preds_table(preds, n_preds=n_preds)
        
        # Log to W&B
        assert wandb.run is not None, "Execute this inside a wandb run"
        pred_artifact = wandb.Artifact(f"run_{wandb.run.id}_preds", type="evaluation")
        pred_artifact.add(self.preds_table, table_name)
        wandb.log_artifact(pred_artifact, aliases=aliases or ["latest"])
        
        # Log the Table to the workspace
        if self.log2workspace:
            wandb.log({"preds_table":self.preds_table}) 
